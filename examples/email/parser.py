# LR(1) parser, autogenerated on 2025-07-05 11:03:43
# generator: wisent 0.6.2, http://seehuhn.de/pages/wisent
# source: examples/email/parser.wi

# All parts of this file which are not taken verbatim from the input grammar
# are covered by the following notice:
#
# Copyright (C) 2008, 2009  Jochen Voss <voss@seehuhn.de>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#   1. Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#   2. Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
#   3. The name of the author may not be used to endorse or promote
#      products derived from this software without specific prior
#      written permission.
#
# This software is provided by the author "as is" and any express or
# implied warranties, including, but not limited to, the implied
# warranties of merchantability and fitness for a particular purpose
# are disclaimed.  In no event shall the author be liable for any
# direct, indirect, incidental, special, exemplary, or consequential
# damages (including, but not limited to, procurement of substitute
# goods or services; loss of use, data, or profits; or business
# interruption) however caused and on any theory of liability, whether
# in contract, strict liability, or tort (including negligence or
# otherwise) arising in any way out of the use of this software, even
# if advised of the possibility of such damage.

from itertools import chain

class Unique(object):

    """Unique objects for use as markers.

    These objects are internally used to represent the start symbol
    and the end-of-input marker of the grammar.
    """

    def __init__(self, label):
        """Create a new unique object.

        `label` is a string which is used as a textual representation
        of the object.
        """
        self.label = label

    def __repr__(self):
        """Return the `label` given at object construction."""
        return self.label

class Parser(object):

    """LR(1) parser class.

    terminal symbols:
      ',', '.', ':', ';', '<', '>', '@', 'atom', 'domain-literal',
      'quoted-string'

    nonterminal symbols:
      'addr-spec', 'address-list', 'angle-addr', 'domain', 'group',
      'group-name', 'local-part', 'mailbox', 'mailbox-name', 'name-addr'

    production rules:
      'address-list' -> '_1*' '_address'
      '_1*' ->
      '_1*' -> '_1*' '_address' '_17+'
      '_address' -> 'mailbox'
      '_address' -> 'group'
      'mailbox' -> 'name-addr'
      'mailbox' -> 'addr-spec'
      'name-addr' -> 'mailbox-name' 'angle-addr'
      'mailbox-name' ->
      'mailbox-name' -> '_9+'
      'angle-addr' -> '<' 'addr-spec' '>'
      'group' -> 'group-name' ':' '_5?' ';'
      '_7*' ->
      '_7*' -> '_7*' 'mailbox' '_17+'
      '_5?' ->
      '_5?' -> '_7*' 'mailbox'
      'group-name' -> '_9+'
      '_9+' -> '_word'
      '_9+' -> '_9+' '_word'
      'addr-spec' -> 'local-part' '@' 'domain'
      'local-part' -> '_word' '_11*'
      '_11*' ->
      '_11*' -> '_11*' '.' '_word'
      'domain' -> '_13*' '_sub-domain'
      '_13*' ->
      '_13*' -> '_13*' '_sub-domain' '.'
      '_sub-domain' -> 'atom'
      '_sub-domain' -> 'domain-literal'
      '_17+' -> ','
      '_17+' -> '_17+' ','
      '_word' -> 'atom'
      '_word' -> 'quoted-string'
    """

    class ParseErrors(Exception):

        """Exception class to represent a collection of parse errors.

        Instances of this class have two attributes, `errors` and `tree`.
        `errors` is a list of tuples, each describing one error.
        Each tuple consists of the first input token which could not
        be processed and the list of grammar symbols which were allowed
        at this point.
        `tree` is a "repaired" parse tree which might be used for further
        error checking, or `None` if no repair was possible.
        """

        def __init__(self, errors, tree):
            msg = "%d parse errors"%len(errors)
            Exception.__init__(self, msg)
            self.errors = errors
            self.tree = tree

    terminals = [ ',', '.', ':', ';', '<', '>', '@', 'atom', 'domain-literal',
                  'quoted-string' ]
    _transparent = [ '_1*', '_11*', '_13*', '_17+', '_5?', '_7*', '_9+',
                     '_address', '_sub-domain', '_word' ]
    EOF = Unique('EOF')
    S = Unique('S')

    _halting_state = 41
    _reduce = {
        (0, '<'): ('_1*', 0), (0, 'atom'): ('_1*', 0),
        (0, 'quoted-string'): ('_1*', 0), (10, ','): ('name-addr', 2),
        (10, ';'): ('name-addr', 2), (10, EOF): ('name-addr', 2),
        (11, ':'): ('group-name', 1), (11, '<'): ('mailbox-name', 1),
        (12, '<'): ('mailbox-name', 1), (15, ','): ('angle-addr', 3),
        (15, ';'): ('angle-addr', 3), (15, EOF): ('angle-addr', 3),
        (17, ';'): ('_5?', 0), (17, '<'): ('_7*', 0), (17, 'atom'): ('_7*', 0),
        (17, 'quoted-string'): ('_7*', 0), (19, ','): ('group', 4),
        (19, EOF): ('group', 4), (2, '<'): ('mailbox-name', 0),
        (20, '<'): ('mailbox-name', 0), (21, ';'): ('_5?', 2),
        (22, '<'): ('_7*', 3), (22, 'atom'): ('_7*', 3),
        (22, 'quoted-string'): ('_7*', 3), (23, '.'): ('_11*', 0),
        (23, ':'): ('_9+', 1), (23, '<'): ('_9+', 1), (23, '@'): ('_11*', 0),
        (23, 'atom'): ('_9+', 1), (23, 'quoted-string'): ('_9+', 1),
        (24, ':'): ('_9+', 2), (24, '<'): ('_9+', 2), (24, 'atom'): ('_9+', 2),
        (24, 'quoted-string'): ('_9+', 2), (26, 'atom'): ('_13*', 0),
        (26, 'domain-literal'): ('_13*', 0), (27, ','): ('addr-spec', 3),
        (27, ';'): ('addr-spec', 3), (27, '>'): ('addr-spec', 3),
        (27, EOF): ('addr-spec', 3), (28, '.'): ('_11*', 0),
        (28, '@'): ('_11*', 0), (29, '@'): ('local-part', 2),
        (3, EOF): ('address-list', 2), (31, '.'): ('_11*', 3),
        (31, '@'): ('_11*', 3), (33, ','): ('domain', 2),
        (33, ';'): ('domain', 2), (33, '>'): ('domain', 2),
        (33, EOF): ('domain', 2), (34, 'atom'): ('_13*', 3),
        (34, 'domain-literal'): ('_13*', 3), (35, ','): ('_sub-domain', 1),
        (35, '.'): ('_sub-domain', 1), (35, ';'): ('_sub-domain', 1),
        (35, '>'): ('_sub-domain', 1), (35, EOF): ('_sub-domain', 1),
        (36, ','): ('_sub-domain', 1), (36, '.'): ('_sub-domain', 1),
        (36, ';'): ('_sub-domain', 1), (36, '>'): ('_sub-domain', 1),
        (36, EOF): ('_sub-domain', 1), (37, ','): ('_17+', 1),
        (37, '<'): ('_17+', 1), (37, 'atom'): ('_17+', 1),
        (37, 'quoted-string'): ('_17+', 1), (38, ','): ('_17+', 2),
        (38, '<'): ('_17+', 2), (38, 'atom'): ('_17+', 2),
        (38, 'quoted-string'): ('_17+', 2), (39, '.'): ('_word', 1),
        (39, ':'): ('_word', 1), (39, '<'): ('_word', 1),
        (39, '@'): ('_word', 1), (39, 'atom'): ('_word', 1),
        (39, 'quoted-string'): ('_word', 1), (4, '<'): ('_1*', 3),
        (4, 'atom'): ('_1*', 3), (4, 'quoted-string'): ('_1*', 3),
        (40, '.'): ('_word', 1), (40, ':'): ('_word', 1),
        (40, '<'): ('_word', 1), (40, '@'): ('_word', 1),
        (40, 'atom'): ('_word', 1), (40, 'quoted-string'): ('_word', 1),
        (5, ','): ('_address', 1), (5, EOF): ('_address', 1),
        (6, ','): ('_address', 1), (6, EOF): ('_address', 1),
        (7, ','): ('mailbox', 1), (7, ';'): ('mailbox', 1),
        (7, EOF): ('mailbox', 1), (8, ','): ('mailbox', 1),
        (8, ';'): ('mailbox', 1), (8, EOF): ('mailbox', 1)
    }
    _goto = {
        (0, '_1*'): 2, (0, 'address-list'): 1, (11, '_word'): 24,
        (12, '_word'): 24, (13, '_word'): 28, (13, 'addr-spec'): 14,
        (13, 'local-part'): 25, (17, '_5?'): 18, (17, '_7*'): 20,
        (2, '_9+'): 11, (2, '_address'): 3, (2, '_word'): 23,
        (2, 'addr-spec'): 8, (2, 'group'): 6, (2, 'group-name'): 16,
        (2, 'local-part'): 25, (2, 'mailbox'): 5, (2, 'mailbox-name'): 9,
        (2, 'name-addr'): 7, (20, '_9+'): 12, (20, '_word'): 23,
        (20, 'addr-spec'): 8, (20, 'local-part'): 25, (20, 'mailbox'): 21,
        (20, 'mailbox-name'): 9, (20, 'name-addr'): 7, (21, '_17+'): 22,
        (23, '_11*'): 29, (26, '_13*'): 32, (26, 'domain'): 27,
        (28, '_11*'): 29, (3, '_17+'): 4, (30, '_word'): 31,
        (32, '_sub-domain'): 33, (9, 'angle-addr'): 10
    }
    _shift = {
        (1, EOF): 41, (11, 'atom'): 39, (11, 'quoted-string'): 40,
        (12, 'atom'): 39, (12, 'quoted-string'): 40, (13, 'atom'): 39,
        (13, 'quoted-string'): 40, (14, '>'): 15, (16, ':'): 17, (18, ';'): 19,
        (2, 'atom'): 39, (2, 'quoted-string'): 40, (20, 'atom'): 39,
        (20, 'quoted-string'): 40, (21, ','): 37, (22, ','): 38, (25, '@'): 26,
        (29, '.'): 30, (3, ','): 37, (30, 'atom'): 39,
        (30, 'quoted-string'): 40, (32, 'atom'): 35,
        (32, 'domain-literal'): 36, (33, '.'): 34, (4, ','): 38, (9, '<'): 13
    }

    def __init__(self, max_err=None, errcorr_pre=4, errcorr_post=4):
        """Create a new parser instance.

        The constructor arguments are all optional, they control the
        handling of parse errors: `max_err` can be given to bound the
        number of errors reported during one run of the parser.
        `errcorr_pre` controls how many tokens before an invalid token
        the parser considers when trying to repair the input.
        `errcorr_post` controls how far beyond an invalid token the
        parser reads when evaluating the quality of an attempted
        repair.
        """
        self.max_err = max_err
        self.m = errcorr_pre
        self.n = errcorr_post

    @staticmethod
    def leaves(tree):
        """Iterate over the leaves of a parse tree.

        This function can be used to reconstruct the input from a
        parse tree.
        """
        if tree[0] in Parser.terminals:
            yield tree
        else:
            for x in tree[1:]:
                for t in Parser.leaves(x):
                    yield t

    def _parse(self, tokens, stack, state):
        """Internal function to construct a parse tree.

        'Tokens' is the input token stream, 'stack' is the inital stack
        and 'state' is the inital state of the automaton.

        Returns a 4-tuple (done, count, state, error).  'done' is a
        boolean indicationg whether parsing is completed, 'count' is
        number of successfully shifted tokens, and 'error' is None on
        success or else the first token which could not be parsed.
        """
        read_next = True
        count = 0
        while state != self._halting_state:
            if read_next:
                try:
                    lookahead = next(tokens)
                except StopIteration:
                    return (False,count,state,None)
                read_next = False
            token = lookahead[0]

            if (state,token) in self._shift:
                stack.append((state,lookahead))
                state = self._shift[(state,token)]
                read_next = True
                count += 1
            elif (state,token) in self._reduce:
                X,n = self._reduce[(state,token)]
                if n > 0:
                    state = stack[-n][0]
                    tree = [ X ]
                    for s in stack[-n:]:
                        if s[1][0] in self._transparent:
                            tree.extend(s[1][1:])
                        else:
                            tree.append(s[1])
                    tree = tuple(tree)
                    del stack[-n:]
                else:
                    tree = (X,)
                stack.append((state,tree))
                state = self._goto[(state,X)]
            else:
                return (False,count,state,lookahead)
        return (True,count,state,None)

    def _try_parse(self, tokens, stack, state):
        count = 0
        while state != self._halting_state and count < len(tokens):
            token = tokens[count][0]

            if (state,token) in self._shift:
                stack.append(state)
                state = self._shift[(state,token)]
                count += 1
            elif (state,token) in self._reduce:
                X,n = self._reduce[(state,token)]
                if n > 0:
                    state = stack[-n]
                    del stack[-n:]
                stack.append(state)
                state = self._goto[(state,X)]
            else:
                break
        return count

    def parse(self, tokens):
        """Parse the tokens from `tokens` and construct a parse tree.

        `tokens` must be an interable over tuples.  The first element
        of each tuple must be a terminal symbol of the grammar which
        is used for parsing.  All other element of the tuple are just
        copied into the constructed parse tree.

        If `tokens` is invalid, a ParseErrors exception is raised.
        Otherwise the function returns the parse tree.
        """
        errors = []
        tokens = chain(tokens, [(self.EOF,)])
        stack = []
        state = 0
        while True:
            done,_,state,lookahead = self._parse(tokens, stack, state)
            if done:
                break

            expect = [ t for s,t in list(self._reduce.keys())+list(self._shift.keys())
                       if s == state ]
            errors.append((lookahead, expect))
            if self.max_err is not None and len(errors) >= self.max_err:
                raise self.ParseErrors(errors, None)

            queue = []
            def split_input(m, stack, lookahead, queue):
                for s in stack:
                    for t in self.leaves(s[1]):
                        queue.append(t)
                        if len(queue) > m:
                            yield queue.pop(0)
                queue.append(lookahead)
            in2 = split_input(self.m, stack, lookahead, queue)
            stack = []
            done,_,state,lookahead = self._parse(in2, stack, 0)
            m = len(queue)
            for i in range(0, self.n):
                try:
                    queue.append(next(tokens))
                except StopIteration:
                    break

            def vary_queue(queue, m):
                for i in range(m-1, -1, -1):
                    for t in self.terminals:
                        yield queue[:i]+[(t,)]+queue[i:]
                    if queue[i][0] == self.EOF:
                        continue
                    for t in self.terminals:
                        if t == queue[i]:
                            continue
                        yield queue[:i]+[(t,)]+queue[i+1:]
                    yield queue[:i]+queue[i+1:]
            best_val = len(queue)-m+1
            best_queue = queue
            for q2 in vary_queue(queue, m):
                pos = self._try_parse(q2, [ s[0] for s in stack ], state)
                val = len(q2) - pos
                if val < best_val:
                    best_val = val
                    best_queue = q2
                    if val == len(q2):
                        break
            if best_val >= len(queue)-m+1:
                raise self.ParseErrors(errors, None)
            tokens = chain(best_queue, tokens)

        tree = stack[0][1]
        if errors:
            raise self.ParseErrors(errors, tree)
        return tree
